# 扫雷问题AI方案

### 1. 问题描述

程序的输入是一个二维矩阵表示每个单元格的状态。

状态一共有 3 种

* 空白
* 未知 Unk
* 数字 Num

我们主要关注 Unk 和 Num， 最朴素的想法如下：

*假设 Unk的长度为 n， 那么一共有$2^n$ 种可能的方案.我们验证并记录每一种满足Num约束的方案(一共有$K, (K<2^n$)种, 现在来看一个Unk格子, 在所有可行方案中该格子有雷的数量为B, 那么该格子为雷的概率为$P= \frac{B}{K}$(*这里的概率是当前步骤的正确率 != 全局的胜利率)*

这引出了一个问题 如何 **枚举** 和 **剪枝**.



### 2. 枚举和剪枝

首先可以想到的是**划分连通域**, 将需要枚举的 Unk 划分为更小的几个部分, 分别进行枚举, 然后将结果合并起来得到最后的选择

##### 2.1 划分连通域

思路:考虑格子的相关性, 我们认为与同一个Num 相邻的多个Unk 是相关联的.并且连通域是依附Num存在的.可以得到如下算法(DFS伪代码):

```python
# 实际实现种添加 Visited 数组防止重复访问
def Visit(Unit, domain):
    if Unit.type == Empty:
        return
    domain.add(Unit)
    for neibor in Unit.NeiborIter():
        if neibor.type != Unit.type:
            Visit(neibor, domain)

```



在实践中发现, 在 50/256 的游戏中连通域一般只有 2-3 个, 而 Unk 数组长度一般在 60-70, 那么每个连通域就会分到 20 - 30 甚至更多的块, 这使得枚举的复杂度可能会超出Python能处理的上限.

玩过扫雷游戏就知道有一些格子可以通过**简单的推理**判断出是否有雷.



##### 2.2 基本推理

说明:由于连通域是按照关联性划分, 那么先进行基本推理和先进行连通域划分的区别不大.

推理主要有两个判断依据:

* 如果一个 Num 单元附近的**已知雷数量** = **其 数值**, 那么其附近的其余块都无雷
* 如果一个 Num 单元附近的 **未知单元数量** + **已知雷数量** = **其数值**, 那么附近的未知单元都是雷.

依据以上的规则可以把需要枚举的单元数量进一步减小.



##### **2.3** 线性方程组法

在基本推理中我们是在通过一些已知的经验来处理Unk数组.

但是该问题实际上是一个 带约束的整数规划问题.

我们需要找到一个 Unk 的子集.

1. 这个子集的任意取值都是合法的 
2. Unk 数组可以由 该子集 和 Num 数组准确的推导出.

原问题相当于解
$$
A\cdot X = B
$$
其中 A 是Num单元和 Unk单元的位置关系, X 是代表 Unk 单元格的可变量, B 是Num的约束信息.

如果 A 的秩为 K 那么: 只需要 枚举 len(X) - K 个变量即可.

解决算法:高斯消元法

算法描述:略



##### 2.4 搜索剪枝法

线性方程组法应该是比较好的方法, 此外还有一种比较容易想到的方法, 是在搜索时剪枝, 我们对 Unk 数组进行枚举的时候, 每确定一个数都对余下的 Unk 单元进行一次基本推理, 可以得到一个更短的待确定Unk数组. 这样可以有效的剪枝. 实践中, 这种方法约等于直接枚举 15- 16个单元的花销.

算法描述:二叉树遍历?深度优先搜索?



### 3. 全局概率的计算

这个概率的计算参考了知乎上别人提出的方法.

由于在划分连通域时我们求解的对象发生了变化, 如果仅仅计算某个单元格在某个连通域内是雷的概率显然是有偏的.

我们应该计算一个全局概率.

方法是: 对每个连通域的雷数进行组合, 使所有连通域雷数量之和为剩余雷的数量, 并且计算满足条件的所有情况中, 某个格子 Unk 是雷的情况数量, 这样就能较准确的得到 该Unk格子是雷的精确概率.

1. blockCnt_s 代表这个连通块中共有 s 颗雷的方案数（检查一个方案是否合法只需要遍历该区域中所有数字， 检查是否合法）这样来的话复杂度就是 $O(cn)$

   

2. cellCnt_x,s表示当前格子 x 所在在连通块中有s颗雷时， 多少种方案里 x 格子是有雷的(on扫一遍)

3. 计算 DP_i,j 代表前 i 个连通块 共有 j 个雷的方案数（背包问题）$O(1)， 这里忽略不计$
   $$
   dp_{i,j} = \sum_{s = 0}^{max}dp_{i-1, j - s} \times blockCnt_s
   $$

4. 假定当前剩余 mine 个雷， 枚举当前所在区域的雷数 s(1 - s), 有：$O(1)$
   $$
   p_x = \frac{\sum_{s=0}^{s_{max}} cellCnt_{x,s} \times dp_{n-1, mine-s}}{\sum_{s=0}^{s_{max}} blockCnt_s\times dp_{n-1, mine-s}}
   $$





算法:动态规划.





### 4. 运行效率

在python环境下， 通过限制最大枚举 格子数（n<18）可以 以0.4s/局的速度和40%+ 的成功率完成1000局测试，

0.4s/局的数据主要由一些特定的局面造成， 如果牺牲一些准确率， 大多数局面仅需要 0.1s就能处理。

影响成功率的很大因素是第一个格子失败， 有一些扫雷的生成程序在第一个格子被点击时生成， 保证第一次点击永远不会踩到雷， 这样成功率回提升很多， p = 50 / (16**2) = 19%